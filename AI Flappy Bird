#FLappy bird 




























class Bird:
    
    # no animation

    def __init__(self, x, y):
        self.x=x
        self.y= y
        self.img=bird_img
        self.tickcount= 0
        self.vel= 0
        self.height= self.y

    def jump(self):
        self.vel= -10.5
        self.tickcount= 0
        self.height= self.y

    def move(self):
        self.tickcount += 1

        d = self.vel * self.tickcount + 1.5*self.tickcount**2

        if d >= 16: # terminal velocity
            d= 16
        if d < 0:
            d -= 2
        self.y = self.y + d  #gravity

    def draw(self, win):
        newrect= bird_img.get_rect(topleft= (self.x, self.y)).center
        win.blit(bird_img, newrect)
        py.display.update()
    
    def get_mask(self):
        return py.mask.from_surface(self.img)


#pipes!!

class Pipe:
    
    
    def __init__(self, x):
        self.x=x
        self.height=0
        self.gap=100
        self.vel=5


        self.top=0
        self.bottom=0
        self.Pipe_Top=py.transform.flip(pipe_img, False, True)
        self.Pipe_Bottom= pipe_img

        self.passed= False
        self.set_height()

    def set_height(self):
        self.height= random.randrange(150, 250)
        self.top= self.height - self.Pipe_Top.get_height()
        self.bottom= self.height + self.gap
    
    def move(self):
        self.x-=self.vel

    def draw(self, win):
        win.blit(self.Pipe_Top, (self.x, self.top))
        win.blit(self.Pipe_Bottom, (self.x, self.bottom))

    def collide(self, bird):
        #get collision area for each sprite
        birdmask= bird.get_mask()
        topmask=py.mask.from_surface(self.Pipe_Top)
        botmask=py.mask.from_surface(self.Pipe_Bottom)

        #constant vars. idk! look up 'pygame mask detection'
    
        top_offset= (self.x - bird.x, self.top - round(bird.y))
        bottom_offset=(self.x - bird.x, self.bottom - round(bird.y))

        #comparing or checking to see if they collide
        b_point= birdmask.overlap(botmask, bottom_offset)
        t_point= birdmask.overlap(topmask, top_offset)
        
        if t_point or b_point:
            return True
        
        return False




class Base:
    vel= 5
    width = baseimg.get_width()
    img = baseimg

    def __init__(self, y):
        self.y = y
        self.x1= 0
        self.x2= self.width

    def move(self):

        #cartoon moving floor!
        self.x1 -= self.vel
        self.x2 -= self.vel

        if self.x1 + self.width < 0:
            self.x1 = self.x2 + self.width

        if self.x2 + self.width < 0:
            self.x2 = self.x1 + self.width

    
    def draw(self, win):
        win.blit(self.img, (self.x1, self.y))
        win.blit(self.img, (self.x2, self.y))






def draw_win(win, birds, pipes, base, score):



    win.fill(white)
    
    for pipe in pipes:
        pipe.draw(win)

    text= statfont.render('score:' +str(score), 1, red)
    win.blit(text, (10,10))


    base.draw(win)

    for bird in birds:
        bird.draw(win)
    
    py.display.update()


#Flappy bird!!!
def main(genomes, config):
    x=600
    nets=[]
    ge=[]
    birds = []

    for _, g in genomes:
        net= neat.nn.FeedForwardNetwork.create(g, config)
        nets.append(net)
        birds.append(Bird(230, 350))
        g.fitness = 0
        ge.append(g)

    base = Base(450)
    pipes = [Pipe(700)]
    win= py.display.set_mode((x, y))
    score= 0

    clock= py.time.Clock()
    run = True
    
    while run:
        clock.tick(30)
        for event in py.event.get():
            if event.type== py.QUIT:
                run = False


        pipe0id=0
        if len(birds) > 0:
            if len(pipes) > 1 and birds[0].x > pipes[0].x + pipes[0].Pipe_Top.get_width():
                pipe0id=1
        else:
            run =False
            break

        for a, bird in enumerate(birds):
            bird.move()
            ge[a].fitness +=0.1

            output = nets[a].activate((bird.y, abs(bird.y - pipes[pipe0id].height), abs(bird.y-pipes[pipe0id].bottom)))

            if output[0] > 0.5:
                bird.jump()



        base.move()
        add_pipe= False
        
        
        rem =[]

        for pipe in pipes:

            #bro this returns a tuple ([0, Bird()], [1, Bird()]) etc.  but mainly etc.
            for x, bird in enumerate(birds):
                #check if pipe collides
                if pipe.collide(bird):
                    ge[x].fitness -=1
                    birds.pop(x)
                    nets.pop(x)
                    ge.pop(x)


                #did we pass the pipe? score?
                if not pipe.passed and pipe.x < bird.x:
                    pipe.passed=True
                    add_pipe= True
                    # remove pipe from screen
            if pipe.x + pipe.Pipe_Top.get_width() < 0:
                rem.append(pipe)


            pipe.move()


        if add_pipe:
            score+=1
            for g in ge:
                g.fitness += 3

            pipes.append(Pipe(700))

        for r in rem:
            pipes.remove(r)

        for x, bird in enumerate(birds):
            if bird.y + bird_img.get_height()>= 700 or bird.y < 0:
                birds.pop(x)
                nets.pop(x)
                ge.pop(x)

        draw_win(win, birds, pipes, base, score)


def run(config_path):
    config= neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction, #sets config.ini
                               neat.DefaultSpeciesSet, neat.DefaultStagnation, config_path)
    p= neat.Population(config) ##loads in population

    p.add_reporter(neat.StdOutReporter(True))  ##output that we see
    stats= neat.StatisticsReporter()
    p.add_reporter(stats)

    winner= p.run(main, 20)  #run a fitness function for x generations ( name(), x) [main= FLappybird]

if __name__ == '__main__':
   localdir=os.path.dirname(__file__)
   config_path= os.path.join(localdir, 'config.ini')
   run(config_path)
